"""@package docstring
HardTask object used for the xbee interface
"""
import sys
from pathlib import Path
from umnsvp_xbee import *
from hard_task import *
import requests
import logging 
sys.path.append(str(Path("../can_packet_parser/")))

from interface_digi_xbee import interface_digi_xbee
from can_packet_codec import XBeeCANPacketCodec

from scrappy import yamls_to_packets

class XbeeTask(HardTask):
    def __init__(self, name: str, server: str, packets: str, com: str, log: str, cache_size: int, cache_time: float):
        """
        Extend the HardTask constructor to initialize the necessary variables for the xbee
        @param name the name of the task
        @param server flask server ip address
        @param packets file location of the packet definitions for parsing
        @param com com port that the xbee is plugged into 
        @param log path to a log file in which to store the data generated by the xbee
        @param cache_size size of the list that will cache the data recieved by the xbee
        @param cache_time the timeout length for caching data so that data in the flask server stays fresh
        """
        self.packets = packets
        self.com = com
        self.log = log
        self.cache_size = cache_size
        self.cache_time = cache_time
        #initialize as a hard task with no repeat
        super().__init__(name, server)

    def update(self, exec_time: float):
        """
        Initialize the callbacks and such that are needed to run the xbee
        Create a logger object for the Xbee
        """

        # Create a Logger object to log to the provided file
        logger = Logger(self.log)

        packet_defs = yamls_to_packets(self.packets)

        interface = interface_digi_xbee(self.com, build_xbee_handler(packet_defs, self.server, logger, self.cache_size,  self.cache_time), codec=XBeeCANPacketCodec())

        interface.main()

        try:
            while True:
                pass

        except KeyboardInterrupt:
            interface.stop()
            logger.close()

        except Exception as err:
            logging.info(f"{self.name} threw {err=}")
            self.terminate()
        
        super().update(exec_time)